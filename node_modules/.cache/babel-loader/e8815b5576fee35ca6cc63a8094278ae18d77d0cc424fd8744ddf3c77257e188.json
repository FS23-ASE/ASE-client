{"ast":null,"code":"'use strict';\n\nimport _classCallCheck from \"/Users/hanli/Desktop/UZH/Advanced Software Engineering/ASE-client/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/hanli/Desktop/UZH/Advanced Software Engineering/ASE-client/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"/Users/hanli/Desktop/UZH/Advanced Software Engineering/ASE-client/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _get from \"/Users/hanli/Desktop/UZH/Advanced Software Engineering/ASE-client/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/Users/hanli/Desktop/UZH/Advanced Software Engineering/ASE-client/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/Users/hanli/Desktop/UZH/Advanced Software Engineering/ASE-client/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/hanli/Desktop/UZH/Advanced Software Engineering/ASE-client/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport stream from 'stream';\nimport utils from '../utils.js';\nimport throttle from './throttle.js';\nimport speedometer from './speedometer.js';\nvar kInternals = Symbol('internals');\nvar AxiosTransformStream = /*#__PURE__*/function (_stream$Transform) {\n  _inherits(AxiosTransformStream, _stream$Transform);\n  var _super = _createSuper(AxiosTransformStream);\n  function AxiosTransformStream(options) {\n    var _this;\n    _classCallCheck(this, AxiosTransformStream);\n    options = utils.toFlatObject(options, {\n      maxRate: 0,\n      chunkSize: 64 * 1024,\n      minChunkSize: 100,\n      timeWindow: 500,\n      ticksRate: 2,\n      samplesCount: 15\n    }, null, function (prop, source) {\n      return !utils.isUndefined(source[prop]);\n    });\n    _this = _super.call(this, {\n      readableHighWaterMark: options.chunkSize\n    });\n    var self = _assertThisInitialized(_this);\n    var internals = _this[kInternals] = {\n      length: options.length,\n      timeWindow: options.timeWindow,\n      ticksRate: options.ticksRate,\n      chunkSize: options.chunkSize,\n      maxRate: options.maxRate,\n      minChunkSize: options.minChunkSize,\n      bytesSeen: 0,\n      isCaptured: false,\n      notifiedBytesLoaded: 0,\n      ts: Date.now(),\n      bytes: 0,\n      onReadCallback: null\n    };\n    var _speedometer = speedometer(internals.ticksRate * options.samplesCount, internals.timeWindow);\n    _this.on('newListener', function (event) {\n      if (event === 'progress') {\n        if (!internals.isCaptured) {\n          internals.isCaptured = true;\n        }\n      }\n    });\n    var bytesNotified = 0;\n    internals.updateProgress = throttle(function throttledHandler() {\n      var totalBytes = internals.length;\n      var bytesTransferred = internals.bytesSeen;\n      var progressBytes = bytesTransferred - bytesNotified;\n      if (!progressBytes || self.destroyed) return;\n      var rate = _speedometer(progressBytes);\n      bytesNotified = bytesTransferred;\n      process.nextTick(function () {\n        self.emit('progress', {\n          'loaded': bytesTransferred,\n          'total': totalBytes,\n          'progress': totalBytes ? bytesTransferred / totalBytes : undefined,\n          'bytes': progressBytes,\n          'rate': rate ? rate : undefined,\n          'estimated': rate && totalBytes && bytesTransferred <= totalBytes ? (totalBytes - bytesTransferred) / rate : undefined\n        });\n      });\n    }, internals.ticksRate);\n    var onFinish = function onFinish() {\n      internals.updateProgress(true);\n    };\n    _this.once('end', onFinish);\n    _this.once('error', onFinish);\n    return _this;\n  }\n  _createClass(AxiosTransformStream, [{\n    key: \"_read\",\n    value: function _read(size) {\n      var internals = this[kInternals];\n      if (internals.onReadCallback) {\n        internals.onReadCallback();\n      }\n      return _get(_getPrototypeOf(AxiosTransformStream.prototype), \"_read\", this).call(this, size);\n    }\n  }, {\n    key: \"_transform\",\n    value: function _transform(chunk, encoding, callback) {\n      var self = this;\n      var internals = this[kInternals];\n      var maxRate = internals.maxRate;\n      var readableHighWaterMark = this.readableHighWaterMark;\n      var timeWindow = internals.timeWindow;\n      var divider = 1000 / timeWindow;\n      var bytesThreshold = maxRate / divider;\n      var minChunkSize = internals.minChunkSize !== false ? Math.max(internals.minChunkSize, bytesThreshold * 0.01) : 0;\n      function pushChunk(_chunk, _callback) {\n        var bytes = Buffer.byteLength(_chunk);\n        internals.bytesSeen += bytes;\n        internals.bytes += bytes;\n        if (internals.isCaptured) {\n          internals.updateProgress();\n        }\n        if (self.push(_chunk)) {\n          process.nextTick(_callback);\n        } else {\n          internals.onReadCallback = function () {\n            internals.onReadCallback = null;\n            process.nextTick(_callback);\n          };\n        }\n      }\n      var transformChunk = function transformChunk(_chunk, _callback) {\n        var chunkSize = Buffer.byteLength(_chunk);\n        var chunkRemainder = null;\n        var maxChunkSize = readableHighWaterMark;\n        var bytesLeft;\n        var passed = 0;\n        if (maxRate) {\n          var now = Date.now();\n          if (!internals.ts || (passed = now - internals.ts) >= timeWindow) {\n            internals.ts = now;\n            bytesLeft = bytesThreshold - internals.bytes;\n            internals.bytes = bytesLeft < 0 ? -bytesLeft : 0;\n            passed = 0;\n          }\n          bytesLeft = bytesThreshold - internals.bytes;\n        }\n        if (maxRate) {\n          if (bytesLeft <= 0) {\n            // next time window\n            return setTimeout(function () {\n              _callback(null, _chunk);\n            }, timeWindow - passed);\n          }\n          if (bytesLeft < maxChunkSize) {\n            maxChunkSize = bytesLeft;\n          }\n        }\n        if (maxChunkSize && chunkSize > maxChunkSize && chunkSize - maxChunkSize > minChunkSize) {\n          chunkRemainder = _chunk.subarray(maxChunkSize);\n          _chunk = _chunk.subarray(0, maxChunkSize);\n        }\n        pushChunk(_chunk, chunkRemainder ? function () {\n          process.nextTick(_callback, null, chunkRemainder);\n        } : _callback);\n      };\n      transformChunk(chunk, function transformNextChunk(err, _chunk) {\n        if (err) {\n          return callback(err);\n        }\n        if (_chunk) {\n          transformChunk(_chunk, transformNextChunk);\n        } else {\n          callback(null);\n        }\n      });\n    }\n  }, {\n    key: \"setLength\",\n    value: function setLength(length) {\n      this[kInternals].length = +length;\n      return this;\n    }\n  }]);\n  return AxiosTransformStream;\n}(stream.Transform);\nexport default AxiosTransformStream;","map":{"version":3,"names":["_classCallCheck","_createClass","_assertThisInitialized","_get","_getPrototypeOf","_inherits","_createSuper","stream","utils","throttle","speedometer","kInternals","Symbol","AxiosTransformStream","_stream$Transform","_super","options","_this","toFlatObject","maxRate","chunkSize","minChunkSize","timeWindow","ticksRate","samplesCount","prop","source","isUndefined","call","readableHighWaterMark","self","internals","length","bytesSeen","isCaptured","notifiedBytesLoaded","ts","Date","now","bytes","onReadCallback","_speedometer","on","event","bytesNotified","updateProgress","throttledHandler","totalBytes","bytesTransferred","progressBytes","destroyed","rate","process","nextTick","emit","undefined","onFinish","once","key","value","_read","size","prototype","_transform","chunk","encoding","callback","divider","bytesThreshold","Math","max","pushChunk","_chunk","_callback","Buffer","byteLength","push","transformChunk","chunkRemainder","maxChunkSize","bytesLeft","passed","setTimeout","subarray","transformNextChunk","err","setLength","Transform"],"sources":["/Users/hanli/Desktop/UZH/Advanced Software Engineering/ASE-client/node_modules/axios/lib/helpers/AxiosTransformStream.js"],"sourcesContent":["'use strict';\n\nimport stream from 'stream';\nimport utils from '../utils.js';\nimport throttle from './throttle.js';\nimport speedometer from './speedometer.js';\n\nconst kInternals = Symbol('internals');\n\nclass AxiosTransformStream extends stream.Transform{\n  constructor(options) {\n    options = utils.toFlatObject(options, {\n      maxRate: 0,\n      chunkSize: 64 * 1024,\n      minChunkSize: 100,\n      timeWindow: 500,\n      ticksRate: 2,\n      samplesCount: 15\n    }, null, (prop, source) => {\n      return !utils.isUndefined(source[prop]);\n    });\n\n    super({\n      readableHighWaterMark: options.chunkSize\n    });\n\n    const self = this;\n\n    const internals = this[kInternals] = {\n      length: options.length,\n      timeWindow: options.timeWindow,\n      ticksRate: options.ticksRate,\n      chunkSize: options.chunkSize,\n      maxRate: options.maxRate,\n      minChunkSize: options.minChunkSize,\n      bytesSeen: 0,\n      isCaptured: false,\n      notifiedBytesLoaded: 0,\n      ts: Date.now(),\n      bytes: 0,\n      onReadCallback: null\n    };\n\n    const _speedometer = speedometer(internals.ticksRate * options.samplesCount, internals.timeWindow);\n\n    this.on('newListener', event => {\n      if (event === 'progress') {\n        if (!internals.isCaptured) {\n          internals.isCaptured = true;\n        }\n      }\n    });\n\n    let bytesNotified = 0;\n\n    internals.updateProgress = throttle(function throttledHandler() {\n      const totalBytes = internals.length;\n      const bytesTransferred = internals.bytesSeen;\n      const progressBytes = bytesTransferred - bytesNotified;\n      if (!progressBytes || self.destroyed) return;\n\n      const rate = _speedometer(progressBytes);\n\n      bytesNotified = bytesTransferred;\n\n      process.nextTick(() => {\n        self.emit('progress', {\n          'loaded': bytesTransferred,\n          'total': totalBytes,\n          'progress': totalBytes ? (bytesTransferred / totalBytes) : undefined,\n          'bytes': progressBytes,\n          'rate': rate ? rate : undefined,\n          'estimated': rate && totalBytes && bytesTransferred <= totalBytes ?\n            (totalBytes - bytesTransferred) / rate : undefined\n        });\n      });\n    }, internals.ticksRate);\n\n    const onFinish = () => {\n      internals.updateProgress(true);\n    };\n\n    this.once('end', onFinish);\n    this.once('error', onFinish);\n  }\n\n  _read(size) {\n    const internals = this[kInternals];\n\n    if (internals.onReadCallback) {\n      internals.onReadCallback();\n    }\n\n    return super._read(size);\n  }\n\n  _transform(chunk, encoding, callback) {\n    const self = this;\n    const internals = this[kInternals];\n    const maxRate = internals.maxRate;\n\n    const readableHighWaterMark = this.readableHighWaterMark;\n\n    const timeWindow = internals.timeWindow;\n\n    const divider = 1000 / timeWindow;\n    const bytesThreshold = (maxRate / divider);\n    const minChunkSize = internals.minChunkSize !== false ? Math.max(internals.minChunkSize, bytesThreshold * 0.01) : 0;\n\n    function pushChunk(_chunk, _callback) {\n      const bytes = Buffer.byteLength(_chunk);\n      internals.bytesSeen += bytes;\n      internals.bytes += bytes;\n\n      if (internals.isCaptured) {\n        internals.updateProgress();\n      }\n\n      if (self.push(_chunk)) {\n        process.nextTick(_callback);\n      } else {\n        internals.onReadCallback = () => {\n          internals.onReadCallback = null;\n          process.nextTick(_callback);\n        };\n      }\n    }\n\n    const transformChunk = (_chunk, _callback) => {\n      const chunkSize = Buffer.byteLength(_chunk);\n      let chunkRemainder = null;\n      let maxChunkSize = readableHighWaterMark;\n      let bytesLeft;\n      let passed = 0;\n\n      if (maxRate) {\n        const now = Date.now();\n\n        if (!internals.ts || (passed = (now - internals.ts)) >= timeWindow) {\n          internals.ts = now;\n          bytesLeft = bytesThreshold - internals.bytes;\n          internals.bytes = bytesLeft < 0 ? -bytesLeft : 0;\n          passed = 0;\n        }\n\n        bytesLeft = bytesThreshold - internals.bytes;\n      }\n\n      if (maxRate) {\n        if (bytesLeft <= 0) {\n          // next time window\n          return setTimeout(() => {\n            _callback(null, _chunk);\n          }, timeWindow - passed);\n        }\n\n        if (bytesLeft < maxChunkSize) {\n          maxChunkSize = bytesLeft;\n        }\n      }\n\n      if (maxChunkSize && chunkSize > maxChunkSize && (chunkSize - maxChunkSize) > minChunkSize) {\n        chunkRemainder = _chunk.subarray(maxChunkSize);\n        _chunk = _chunk.subarray(0, maxChunkSize);\n      }\n\n      pushChunk(_chunk, chunkRemainder ? () => {\n        process.nextTick(_callback, null, chunkRemainder);\n      } : _callback);\n    };\n\n    transformChunk(chunk, function transformNextChunk(err, _chunk) {\n      if (err) {\n        return callback(err);\n      }\n\n      if (_chunk) {\n        transformChunk(_chunk, transformNextChunk);\n      } else {\n        callback(null);\n      }\n    });\n  }\n\n  setLength(length) {\n    this[kInternals].length = +length;\n    return this;\n  }\n}\n\nexport default AxiosTransformStream;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}