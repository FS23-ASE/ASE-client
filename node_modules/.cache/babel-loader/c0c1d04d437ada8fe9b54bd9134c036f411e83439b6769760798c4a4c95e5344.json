{"ast":null,"code":"'use strict';\n\nimport _regeneratorRuntime from \"/Users/hanli/Desktop/UZH/Advanced Software Engineering/ASE-client/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/hanli/Desktop/UZH/Advanced Software Engineering/ASE-client/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport utils from './../utils.js';\nimport settle from './../core/settle.js';\nimport buildFullPath from '../core/buildFullPath.js';\nimport buildURL from './../helpers/buildURL.js';\nimport { getProxyForUrl } from 'proxy-from-env';\nimport http from 'http';\nimport https from 'https';\nimport util from 'util';\nimport followRedirects from 'follow-redirects';\nimport zlib from 'zlib';\nimport { VERSION } from '../env/data.js';\nimport transitionalDefaults from '../defaults/transitional.js';\nimport AxiosError from '../core/AxiosError.js';\nimport CanceledError from '../cancel/CanceledError.js';\nimport platform from '../platform/index.js';\nimport fromDataURI from '../helpers/fromDataURI.js';\nimport stream from 'stream';\nimport AxiosHeaders from '../core/AxiosHeaders.js';\nimport AxiosTransformStream from '../helpers/AxiosTransformStream.js';\nimport EventEmitter from 'events';\nimport formDataToStream from \"../helpers/formDataToStream.js\";\nimport readBlob from \"../helpers/readBlob.js\";\nimport ZlibHeaderTransformStream from '../helpers/ZlibHeaderTransformStream.js';\nvar zlibOptions = {\n  flush: zlib.constants.Z_SYNC_FLUSH,\n  finishFlush: zlib.constants.Z_SYNC_FLUSH\n};\nvar brotliOptions = {\n  flush: zlib.constants.BROTLI_OPERATION_FLUSH,\n  finishFlush: zlib.constants.BROTLI_OPERATION_FLUSH\n};\nvar isBrotliSupported = utils.isFunction(zlib.createBrotliDecompress);\nvar httpFollow = followRedirects.http,\n  httpsFollow = followRedirects.https;\nvar isHttps = /https:?/;\nvar supportedProtocols = platform.protocols.map(function (protocol) {\n  return protocol + ':';\n});\n\n/**\n * If the proxy or config beforeRedirects functions are defined, call them with the options\n * object.\n *\n * @param {Object<string, any>} options - The options object that was passed to the request.\n *\n * @returns {Object<string, any>}\n */\nfunction dispatchBeforeRedirect(options) {\n  if (options.beforeRedirects.proxy) {\n    options.beforeRedirects.proxy(options);\n  }\n  if (options.beforeRedirects.config) {\n    options.beforeRedirects.config(options);\n  }\n}\n\n/**\n * If the proxy or config afterRedirects functions are defined, call them with the options\n *\n * @param {http.ClientRequestArgs} options\n * @param {AxiosProxyConfig} configProxy configuration from Axios options object\n * @param {string} location\n *\n * @returns {http.ClientRequestArgs}\n */\nfunction setProxy(options, configProxy, location) {\n  var proxy = configProxy;\n  if (!proxy && proxy !== false) {\n    var proxyUrl = getProxyForUrl(location);\n    if (proxyUrl) {\n      proxy = new URL(proxyUrl);\n    }\n  }\n  if (proxy) {\n    // Basic proxy authorization\n    if (proxy.username) {\n      proxy.auth = (proxy.username || '') + ':' + (proxy.password || '');\n    }\n    if (proxy.auth) {\n      // Support proxy auth object form\n      if (proxy.auth.username || proxy.auth.password) {\n        proxy.auth = (proxy.auth.username || '') + ':' + (proxy.auth.password || '');\n      }\n      var base64 = Buffer.from(proxy.auth, 'utf8').toString('base64');\n      options.headers['Proxy-Authorization'] = 'Basic ' + base64;\n    }\n    options.headers.host = options.hostname + (options.port ? ':' + options.port : '');\n    var proxyHost = proxy.hostname || proxy.host;\n    options.hostname = proxyHost;\n    // Replace 'host' since options is not a URL object\n    options.host = proxyHost;\n    options.port = proxy.port;\n    options.path = location;\n    if (proxy.protocol) {\n      options.protocol = proxy.protocol.includes(':') ? proxy.protocol : \"\".concat(proxy.protocol, \":\");\n    }\n  }\n  options.beforeRedirects.proxy = function beforeRedirect(redirectOptions) {\n    // Configure proxy for redirected request, passing the original config proxy to apply\n    // the exact same logic as if the redirected request was performed by axios directly.\n    setProxy(redirectOptions, configProxy, redirectOptions.href);\n  };\n}\nvar isHttpAdapterSupported = typeof process !== 'undefined' && utils.kindOf(process) === 'process';\n\n// temporary hotfix\n\nvar wrapAsync = function wrapAsync(asyncExecutor) {\n  return new Promise(function (resolve, reject) {\n    var onDone;\n    var isDone;\n    var done = function done(value, isRejected) {\n      if (isDone) return;\n      isDone = true;\n      onDone && onDone(value, isRejected);\n    };\n    var _resolve = function _resolve(value) {\n      done(value);\n      resolve(value);\n    };\n    var _reject = function _reject(reason) {\n      done(reason, true);\n      reject(reason);\n    };\n    asyncExecutor(_resolve, _reject, function (onDoneHandler) {\n      return onDone = onDoneHandler;\n    }).catch(_reject);\n  });\n};\n\n/*eslint consistent-return:0*/\nexport default isHttpAdapterSupported && function httpAdapter(config) {\n  return wrapAsync( /*#__PURE__*/function () {\n    var _dispatchHttpRequest = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(resolve, reject, onDone) {\n      var data, responseType, responseEncoding, method, isDone, rejected, req, emitter, onFinished, abort, fullPath, parsed, protocol, convertedData, headers, onDownloadProgress, onUploadProgress, maxRate, maxUploadRate, maxDownloadRate, userBoundary, knownLength, contentLength, auth, username, password, urlUsername, urlPassword, path, customErr, options, transport, isHttpsRequest, timeout, ended, errored;\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            abort = function _abort(reason) {\n              emitter.emit('abort', !reason || reason.type ? new CanceledError(null, config, req) : reason);\n            };\n            data = config.data;\n            responseType = config.responseType, responseEncoding = config.responseEncoding;\n            method = config.method.toUpperCase();\n            rejected = false;\n            // temporary internal emitter until the AxiosRequest class will be implemented\n            emitter = new EventEmitter();\n            onFinished = function onFinished() {\n              if (config.cancelToken) {\n                config.cancelToken.unsubscribe(abort);\n              }\n              if (config.signal) {\n                config.signal.removeEventListener('abort', abort);\n              }\n              emitter.removeAllListeners();\n            };\n            onDone(function (value, isRejected) {\n              isDone = true;\n              if (isRejected) {\n                rejected = true;\n                onFinished();\n              }\n            });\n            emitter.once('abort', reject);\n            if (config.cancelToken || config.signal) {\n              config.cancelToken && config.cancelToken.subscribe(abort);\n              if (config.signal) {\n                config.signal.aborted ? abort() : config.signal.addEventListener('abort', abort);\n              }\n            }\n\n            // Parse url\n            fullPath = buildFullPath(config.baseURL, config.url);\n            parsed = new URL(fullPath, 'http://localhost');\n            protocol = parsed.protocol || supportedProtocols[0];\n            if (!(protocol === 'data:')) {\n              _context.next = 25;\n              break;\n            }\n            if (!(method !== 'GET')) {\n              _context.next = 16;\n              break;\n            }\n            return _context.abrupt(\"return\", settle(resolve, reject, {\n              status: 405,\n              statusText: 'method not allowed',\n              headers: {},\n              config: config\n            }));\n          case 16:\n            _context.prev = 16;\n            convertedData = fromDataURI(config.url, responseType === 'blob', {\n              Blob: config.env && config.env.Blob\n            });\n            _context.next = 23;\n            break;\n          case 20:\n            _context.prev = 20;\n            _context.t0 = _context[\"catch\"](16);\n            throw AxiosError.from(_context.t0, AxiosError.ERR_BAD_REQUEST, config);\n          case 23:\n            if (responseType === 'text') {\n              convertedData = convertedData.toString(responseEncoding);\n              if (!responseEncoding || responseEncoding === 'utf8') {\n                convertedData = utils.stripBOM(convertedData);\n              }\n            } else if (responseType === 'stream') {\n              convertedData = stream.Readable.from(convertedData);\n            }\n            return _context.abrupt(\"return\", settle(resolve, reject, {\n              data: convertedData,\n              status: 200,\n              statusText: 'OK',\n              headers: new AxiosHeaders(),\n              config: config\n            }));\n          case 25:\n            if (!(supportedProtocols.indexOf(protocol) === -1)) {\n              _context.next = 27;\n              break;\n            }\n            return _context.abrupt(\"return\", reject(new AxiosError('Unsupported protocol ' + protocol, AxiosError.ERR_BAD_REQUEST, config)));\n          case 27:\n            headers = AxiosHeaders.from(config.headers).normalize(); // Set User-Agent (required by some servers)\n            // See https://github.com/axios/axios/issues/69\n            // User-Agent is specified; handle case where no UA header is desired\n            // Only set header if it hasn't been set in config\n            headers.set('User-Agent', 'axios/' + VERSION, false);\n            onDownloadProgress = config.onDownloadProgress;\n            onUploadProgress = config.onUploadProgress;\n            maxRate = config.maxRate;\n            maxUploadRate = undefined;\n            maxDownloadRate = undefined; // support for spec compliant FormData objects\n            if (!utils.isSpecCompliantForm(data)) {\n              _context.next = 39;\n              break;\n            }\n            userBoundary = headers.getContentType(/boundary=([-_\\w\\d]{10,70})/i);\n            data = formDataToStream(data, function (formHeaders) {\n              headers.set(formHeaders);\n            }, {\n              tag: \"axios-\".concat(VERSION, \"-boundary\"),\n              boundary: userBoundary && userBoundary[1] || undefined\n            });\n            // support for https://www.npmjs.com/package/form-data api\n            _context.next = 75;\n            break;\n          case 39:\n            if (!(utils.isFormData(data) && utils.isFunction(data.getHeaders))) {\n              _context.next = 53;\n              break;\n            }\n            headers.set(data.getHeaders());\n            if (headers.hasContentLength()) {\n              _context.next = 51;\n              break;\n            }\n            _context.prev = 42;\n            _context.next = 45;\n            return util.promisify(data.getLength).call(data);\n          case 45:\n            knownLength = _context.sent;\n            Number.isFinite(knownLength) && knownLength >= 0 && headers.setContentLength(knownLength);\n            /*eslint no-empty:0*/\n            _context.next = 51;\n            break;\n          case 49:\n            _context.prev = 49;\n            _context.t1 = _context[\"catch\"](42);\n          case 51:\n            _context.next = 75;\n            break;\n          case 53:\n            if (!utils.isBlob(data)) {\n              _context.next = 59;\n              break;\n            }\n            data.size && headers.setContentType(data.type || 'application/octet-stream');\n            headers.setContentLength(data.size || 0);\n            data = stream.Readable.from(readBlob(data));\n            _context.next = 75;\n            break;\n          case 59:\n            if (!(data && !utils.isStream(data))) {\n              _context.next = 75;\n              break;\n            }\n            if (!Buffer.isBuffer(data)) {\n              _context.next = 63;\n              break;\n            }\n            _context.next = 72;\n            break;\n          case 63:\n            if (!utils.isArrayBuffer(data)) {\n              _context.next = 67;\n              break;\n            }\n            data = Buffer.from(new Uint8Array(data));\n            _context.next = 72;\n            break;\n          case 67:\n            if (!utils.isString(data)) {\n              _context.next = 71;\n              break;\n            }\n            data = Buffer.from(data, 'utf-8');\n            _context.next = 72;\n            break;\n          case 71:\n            return _context.abrupt(\"return\", reject(new AxiosError('Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream', AxiosError.ERR_BAD_REQUEST, config)));\n          case 72:\n            // Add Content-Length header if data exists\n            headers.setContentLength(data.length, false);\n            if (!(config.maxBodyLength > -1 && data.length > config.maxBodyLength)) {\n              _context.next = 75;\n              break;\n            }\n            return _context.abrupt(\"return\", reject(new AxiosError('Request body larger than maxBodyLength limit', AxiosError.ERR_BAD_REQUEST, config)));\n          case 75:\n            contentLength = utils.toFiniteNumber(headers.getContentLength());\n            if (utils.isArray(maxRate)) {\n              maxUploadRate = maxRate[0];\n              maxDownloadRate = maxRate[1];\n            } else {\n              maxUploadRate = maxDownloadRate = maxRate;\n            }\n            if (data && (onUploadProgress || maxUploadRate)) {\n              if (!utils.isStream(data)) {\n                data = stream.Readable.from(data, {\n                  objectMode: false\n                });\n              }\n              data = stream.pipeline([data, new AxiosTransformStream({\n                length: contentLength,\n                maxRate: utils.toFiniteNumber(maxUploadRate)\n              })], utils.noop);\n              onUploadProgress && data.on('progress', function (progress) {\n                onUploadProgress(Object.assign(progress, {\n                  upload: true\n                }));\n              });\n            }\n\n            // HTTP basic authentication\n            auth = undefined;\n            if (config.auth) {\n              username = config.auth.username || '';\n              password = config.auth.password || '';\n              auth = username + ':' + password;\n            }\n            if (!auth && parsed.username) {\n              urlUsername = parsed.username;\n              urlPassword = parsed.password;\n              auth = urlUsername + ':' + urlPassword;\n            }\n            auth && headers.delete('authorization');\n            _context.prev = 82;\n            path = buildURL(parsed.pathname + parsed.search, config.params, config.paramsSerializer).replace(/^\\?/, '');\n            _context.next = 93;\n            break;\n          case 86:\n            _context.prev = 86;\n            _context.t2 = _context[\"catch\"](82);\n            customErr = new Error(_context.t2.message);\n            customErr.config = config;\n            customErr.url = config.url;\n            customErr.exists = true;\n            return _context.abrupt(\"return\", reject(customErr));\n          case 93:\n            headers.set('Accept-Encoding', 'gzip, compress, deflate' + (isBrotliSupported ? ', br' : ''), false);\n            options = {\n              path: path,\n              method: method,\n              headers: headers.toJSON(),\n              agents: {\n                http: config.httpAgent,\n                https: config.httpsAgent\n              },\n              auth: auth,\n              protocol: protocol,\n              beforeRedirect: dispatchBeforeRedirect,\n              beforeRedirects: {}\n            };\n            if (config.socketPath) {\n              options.socketPath = config.socketPath;\n            } else {\n              options.hostname = parsed.hostname;\n              options.port = parsed.port;\n              setProxy(options, config.proxy, protocol + '//' + parsed.hostname + (parsed.port ? ':' + parsed.port : '') + options.path);\n            }\n            isHttpsRequest = isHttps.test(options.protocol);\n            options.agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;\n            if (config.transport) {\n              transport = config.transport;\n            } else if (config.maxRedirects === 0) {\n              transport = isHttpsRequest ? https : http;\n            } else {\n              if (config.maxRedirects) {\n                options.maxRedirects = config.maxRedirects;\n              }\n              if (config.beforeRedirect) {\n                options.beforeRedirects.config = config.beforeRedirect;\n              }\n              transport = isHttpsRequest ? httpsFollow : httpFollow;\n            }\n            if (config.maxBodyLength > -1) {\n              options.maxBodyLength = config.maxBodyLength;\n            } else {\n              // follow-redirects does not skip comparison, so it should always succeed for axios -1 unlimited\n              options.maxBodyLength = Infinity;\n            }\n            if (config.insecureHTTPParser) {\n              options.insecureHTTPParser = config.insecureHTTPParser;\n            }\n\n            // Create the request\n            req = transport.request(options, function handleResponse(res) {\n              if (req.destroyed) return;\n              var streams = [res];\n              var responseLength = +res.headers['content-length'];\n              if (onDownloadProgress) {\n                var transformStream = new AxiosTransformStream({\n                  length: utils.toFiniteNumber(responseLength),\n                  maxRate: utils.toFiniteNumber(maxDownloadRate)\n                });\n                onDownloadProgress && transformStream.on('progress', function (progress) {\n                  onDownloadProgress(Object.assign(progress, {\n                    download: true\n                  }));\n                });\n                streams.push(transformStream);\n              }\n\n              // decompress the response body transparently if required\n              var responseStream = res;\n\n              // return the last request in case of redirects\n              var lastRequest = res.req || req;\n\n              // if decompress disabled we should not decompress\n              if (config.decompress !== false && res.headers['content-encoding']) {\n                // if no content, but headers still say that it is encoded,\n                // remove the header not confuse downstream operations\n                if (method === 'HEAD' || res.statusCode === 204) {\n                  delete res.headers['content-encoding'];\n                }\n                switch (res.headers['content-encoding']) {\n                  /*eslint default-case:0*/\n                  case 'gzip':\n                  case 'x-gzip':\n                  case 'compress':\n                  case 'x-compress':\n                    // add the unzipper to the body stream processing pipeline\n                    streams.push(zlib.createUnzip(zlibOptions));\n\n                    // remove the content-encoding in order to not confuse downstream operations\n                    delete res.headers['content-encoding'];\n                    break;\n                  case 'deflate':\n                    streams.push(new ZlibHeaderTransformStream());\n\n                    // add the unzipper to the body stream processing pipeline\n                    streams.push(zlib.createUnzip(zlibOptions));\n\n                    // remove the content-encoding in order to not confuse downstream operations\n                    delete res.headers['content-encoding'];\n                    break;\n                  case 'br':\n                    if (isBrotliSupported) {\n                      streams.push(zlib.createBrotliDecompress(brotliOptions));\n                      delete res.headers['content-encoding'];\n                    }\n                }\n              }\n              responseStream = streams.length > 1 ? stream.pipeline(streams, utils.noop) : streams[0];\n              var offListeners = stream.finished(responseStream, function () {\n                offListeners();\n                onFinished();\n              });\n              var response = {\n                status: res.statusCode,\n                statusText: res.statusMessage,\n                headers: new AxiosHeaders(res.headers),\n                config: config,\n                request: lastRequest\n              };\n              if (responseType === 'stream') {\n                response.data = responseStream;\n                settle(resolve, reject, response);\n              } else {\n                var responseBuffer = [];\n                var totalResponseBytes = 0;\n                responseStream.on('data', function handleStreamData(chunk) {\n                  responseBuffer.push(chunk);\n                  totalResponseBytes += chunk.length;\n\n                  // make sure the content length is not over the maxContentLength if specified\n                  if (config.maxContentLength > -1 && totalResponseBytes > config.maxContentLength) {\n                    // stream.destroy() emit aborted event before calling reject() on Node.js v16\n                    rejected = true;\n                    responseStream.destroy();\n                    reject(new AxiosError('maxContentLength size of ' + config.maxContentLength + ' exceeded', AxiosError.ERR_BAD_RESPONSE, config, lastRequest));\n                  }\n                });\n                responseStream.on('aborted', function handlerStreamAborted() {\n                  if (rejected) {\n                    return;\n                  }\n                  var err = new AxiosError('maxContentLength size of ' + config.maxContentLength + ' exceeded', AxiosError.ERR_BAD_RESPONSE, config, lastRequest);\n                  responseStream.destroy(err);\n                  reject(err);\n                });\n                responseStream.on('error', function handleStreamError(err) {\n                  if (req.destroyed) return;\n                  reject(AxiosError.from(err, null, config, lastRequest));\n                });\n                responseStream.on('end', function handleStreamEnd() {\n                  try {\n                    var responseData = responseBuffer.length === 1 ? responseBuffer[0] : Buffer.concat(responseBuffer);\n                    if (responseType !== 'arraybuffer') {\n                      responseData = responseData.toString(responseEncoding);\n                      if (!responseEncoding || responseEncoding === 'utf8') {\n                        responseData = utils.stripBOM(responseData);\n                      }\n                    }\n                    response.data = responseData;\n                  } catch (err) {\n                    reject(AxiosError.from(err, null, config, response.request, response));\n                  }\n                  settle(resolve, reject, response);\n                });\n              }\n              emitter.once('abort', function (err) {\n                if (!responseStream.destroyed) {\n                  responseStream.emit('error', err);\n                  responseStream.destroy();\n                }\n              });\n            });\n            emitter.once('abort', function (err) {\n              reject(err);\n              req.destroy(err);\n            });\n\n            // Handle errors\n            req.on('error', function handleRequestError(err) {\n              // @todo remove\n              // if (req.aborted && err.code !== AxiosError.ERR_FR_TOO_MANY_REDIRECTS) return;\n              reject(AxiosError.from(err, null, config, req));\n            });\n\n            // set tcp keep alive to prevent drop connection by peer\n            req.on('socket', function handleRequestSocket(socket) {\n              // default interval of sending ack packet is 1 minute\n              socket.setKeepAlive(true, 1000 * 60);\n            });\n\n            // Handle request timeout\n            if (!config.timeout) {\n              _context.next = 111;\n              break;\n            }\n            // This is forcing a int timeout to avoid problems if the `req` interface doesn't handle other types.\n            timeout = parseInt(config.timeout, 10);\n            if (!isNaN(timeout)) {\n              _context.next = 110;\n              break;\n            }\n            reject(new AxiosError('error trying to parse `config.timeout` to int', AxiosError.ERR_BAD_OPTION_VALUE, config, req));\n            return _context.abrupt(\"return\");\n          case 110:\n            // Sometime, the response will be very slow, and does not respond, the connect event will be block by event loop system.\n            // And timer callback will be fired, and abort() will be invoked before connection, then get \"socket hang up\" and code ECONNRESET.\n            // At this time, if we have a large number of request, nodejs will hang up some socket on background. and the number will up and up.\n            // And then these socket which be hang up will devouring CPU little by little.\n            // ClientRequest.setTimeout will be fired on the specify milliseconds, and can make sure that abort() will be fired after connect.\n            req.setTimeout(timeout, function handleRequestTimeout() {\n              if (isDone) return;\n              var timeoutErrorMessage = config.timeout ? 'timeout of ' + config.timeout + 'ms exceeded' : 'timeout exceeded';\n              var transitional = config.transitional || transitionalDefaults;\n              if (config.timeoutErrorMessage) {\n                timeoutErrorMessage = config.timeoutErrorMessage;\n              }\n              reject(new AxiosError(timeoutErrorMessage, transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED, config, req));\n              abort();\n            });\n          case 111:\n            // Send the request\n            if (utils.isStream(data)) {\n              ended = false;\n              errored = false;\n              data.on('end', function () {\n                ended = true;\n              });\n              data.once('error', function (err) {\n                errored = true;\n                req.destroy(err);\n              });\n              data.on('close', function () {\n                if (!ended && !errored) {\n                  abort(new CanceledError('Request stream has been aborted', config, req));\n                }\n              });\n              data.pipe(req);\n            } else {\n              req.end(data);\n            }\n          case 112:\n          case \"end\":\n            return _context.stop();\n        }\n      }, _callee, null, [[16, 20], [42, 49], [82, 86]]);\n    }));\n    function dispatchHttpRequest(_x, _x2, _x3) {\n      return _dispatchHttpRequest.apply(this, arguments);\n    }\n    return dispatchHttpRequest;\n  }());\n};\nexport var __setProxy = setProxy;","map":{"version":3,"names":["_regeneratorRuntime","_asyncToGenerator","utils","settle","buildFullPath","buildURL","getProxyForUrl","http","https","util","followRedirects","zlib","VERSION","transitionalDefaults","AxiosError","CanceledError","platform","fromDataURI","stream","AxiosHeaders","AxiosTransformStream","EventEmitter","formDataToStream","readBlob","ZlibHeaderTransformStream","zlibOptions","flush","constants","Z_SYNC_FLUSH","finishFlush","brotliOptions","BROTLI_OPERATION_FLUSH","isBrotliSupported","isFunction","createBrotliDecompress","httpFollow","httpsFollow","isHttps","supportedProtocols","protocols","map","protocol","dispatchBeforeRedirect","options","beforeRedirects","proxy","config","setProxy","configProxy","location","proxyUrl","URL","username","auth","password","base64","Buffer","from","toString","headers","host","hostname","port","proxyHost","path","includes","concat","beforeRedirect","redirectOptions","href","isHttpAdapterSupported","process","kindOf","wrapAsync","asyncExecutor","Promise","resolve","reject","onDone","isDone","done","value","isRejected","_resolve","_reject","reason","onDoneHandler","catch","httpAdapter","_dispatchHttpRequest","mark","_callee","data","responseType","responseEncoding","method","rejected","req","emitter","onFinished","abort","fullPath","parsed","convertedData","onDownloadProgress","onUploadProgress","maxRate","maxUploadRate","maxDownloadRate","userBoundary","knownLength","contentLength","urlUsername","urlPassword","customErr","transport","isHttpsRequest","timeout","ended","errored","wrap","_callee$","_context","prev","next","_abort","emit","type","toUpperCase","cancelToken","unsubscribe","signal","removeEventListener","removeAllListeners","once","subscribe","aborted","addEventListener","baseURL","url","abrupt","status","statusText","Blob","env","t0","ERR_BAD_REQUEST","stripBOM","Readable","indexOf","normalize","set","undefined","isSpecCompliantForm","getContentType","formHeaders","tag","boundary","isFormData","getHeaders","hasContentLength","promisify","getLength","call","sent","Number","isFinite","setContentLength","t1","isBlob","size","setContentType","isStream","isBuffer","isArrayBuffer","Uint8Array","isString","length","maxBodyLength","toFiniteNumber","getContentLength","isArray","objectMode","pipeline","noop","on","progress","Object","assign","upload","delete","pathname","search","params","paramsSerializer","replace","t2","Error","message","exists","toJSON","agents","httpAgent","httpsAgent","socketPath","test","agent","maxRedirects","Infinity","insecureHTTPParser","request","handleResponse","res","destroyed","streams","responseLength","transformStream","download","push","responseStream","lastRequest","decompress","statusCode","createUnzip","offListeners","finished","response","statusMessage","responseBuffer","totalResponseBytes","handleStreamData","chunk","maxContentLength","destroy","ERR_BAD_RESPONSE","handlerStreamAborted","err","handleStreamError","handleStreamEnd","responseData","handleRequestError","handleRequestSocket","socket","setKeepAlive","parseInt","isNaN","ERR_BAD_OPTION_VALUE","setTimeout","handleRequestTimeout","timeoutErrorMessage","transitional","clarifyTimeoutError","ETIMEDOUT","ECONNABORTED","pipe","end","stop","dispatchHttpRequest","_x","_x2","_x3","apply","arguments","__setProxy"],"sources":["/Users/hanli/Desktop/UZH/Advanced Software Engineering/ASE-client/node_modules/axios/lib/adapters/http.js"],"sourcesContent":["'use strict';\n\nimport utils from './../utils.js';\nimport settle from './../core/settle.js';\nimport buildFullPath from '../core/buildFullPath.js';\nimport buildURL from './../helpers/buildURL.js';\nimport {getProxyForUrl} from 'proxy-from-env';\nimport http from 'http';\nimport https from 'https';\nimport util from 'util';\nimport followRedirects from 'follow-redirects';\nimport zlib from 'zlib';\nimport {VERSION} from '../env/data.js';\nimport transitionalDefaults from '../defaults/transitional.js';\nimport AxiosError from '../core/AxiosError.js';\nimport CanceledError from '../cancel/CanceledError.js';\nimport platform from '../platform/index.js';\nimport fromDataURI from '../helpers/fromDataURI.js';\nimport stream from 'stream';\nimport AxiosHeaders from '../core/AxiosHeaders.js';\nimport AxiosTransformStream from '../helpers/AxiosTransformStream.js';\nimport EventEmitter from 'events';\nimport formDataToStream from \"../helpers/formDataToStream.js\";\nimport readBlob from \"../helpers/readBlob.js\";\nimport ZlibHeaderTransformStream from '../helpers/ZlibHeaderTransformStream.js';\n\nconst zlibOptions = {\n  flush: zlib.constants.Z_SYNC_FLUSH,\n  finishFlush: zlib.constants.Z_SYNC_FLUSH\n};\n\nconst brotliOptions = {\n  flush: zlib.constants.BROTLI_OPERATION_FLUSH,\n  finishFlush: zlib.constants.BROTLI_OPERATION_FLUSH\n}\n\nconst isBrotliSupported = utils.isFunction(zlib.createBrotliDecompress);\n\nconst {http: httpFollow, https: httpsFollow} = followRedirects;\n\nconst isHttps = /https:?/;\n\nconst supportedProtocols = platform.protocols.map(protocol => {\n  return protocol + ':';\n});\n\n/**\n * If the proxy or config beforeRedirects functions are defined, call them with the options\n * object.\n *\n * @param {Object<string, any>} options - The options object that was passed to the request.\n *\n * @returns {Object<string, any>}\n */\nfunction dispatchBeforeRedirect(options) {\n  if (options.beforeRedirects.proxy) {\n    options.beforeRedirects.proxy(options);\n  }\n  if (options.beforeRedirects.config) {\n    options.beforeRedirects.config(options);\n  }\n}\n\n/**\n * If the proxy or config afterRedirects functions are defined, call them with the options\n *\n * @param {http.ClientRequestArgs} options\n * @param {AxiosProxyConfig} configProxy configuration from Axios options object\n * @param {string} location\n *\n * @returns {http.ClientRequestArgs}\n */\nfunction setProxy(options, configProxy, location) {\n  let proxy = configProxy;\n  if (!proxy && proxy !== false) {\n    const proxyUrl = getProxyForUrl(location);\n    if (proxyUrl) {\n      proxy = new URL(proxyUrl);\n    }\n  }\n  if (proxy) {\n    // Basic proxy authorization\n    if (proxy.username) {\n      proxy.auth = (proxy.username || '') + ':' + (proxy.password || '');\n    }\n\n    if (proxy.auth) {\n      // Support proxy auth object form\n      if (proxy.auth.username || proxy.auth.password) {\n        proxy.auth = (proxy.auth.username || '') + ':' + (proxy.auth.password || '');\n      }\n      const base64 = Buffer\n        .from(proxy.auth, 'utf8')\n        .toString('base64');\n      options.headers['Proxy-Authorization'] = 'Basic ' + base64;\n    }\n\n    options.headers.host = options.hostname + (options.port ? ':' + options.port : '');\n    const proxyHost = proxy.hostname || proxy.host;\n    options.hostname = proxyHost;\n    // Replace 'host' since options is not a URL object\n    options.host = proxyHost;\n    options.port = proxy.port;\n    options.path = location;\n    if (proxy.protocol) {\n      options.protocol = proxy.protocol.includes(':') ? proxy.protocol : `${proxy.protocol}:`;\n    }\n  }\n\n  options.beforeRedirects.proxy = function beforeRedirect(redirectOptions) {\n    // Configure proxy for redirected request, passing the original config proxy to apply\n    // the exact same logic as if the redirected request was performed by axios directly.\n    setProxy(redirectOptions, configProxy, redirectOptions.href);\n  };\n}\n\nconst isHttpAdapterSupported = typeof process !== 'undefined' && utils.kindOf(process) === 'process';\n\n// temporary hotfix\n\nconst wrapAsync = (asyncExecutor) => {\n  return new Promise((resolve, reject) => {\n    let onDone;\n    let isDone;\n\n    const done = (value, isRejected) => {\n      if (isDone) return;\n      isDone = true;\n      onDone && onDone(value, isRejected);\n    }\n\n    const _resolve = (value) => {\n      done(value);\n      resolve(value);\n    };\n\n    const _reject = (reason) => {\n      done(reason, true);\n      reject(reason);\n    }\n\n    asyncExecutor(_resolve, _reject, (onDoneHandler) => (onDone = onDoneHandler)).catch(_reject);\n  })\n};\n\n/*eslint consistent-return:0*/\nexport default isHttpAdapterSupported && function httpAdapter(config) {\n  return wrapAsync(async function dispatchHttpRequest(resolve, reject, onDone) {\n    let {data} = config;\n    const {responseType, responseEncoding} = config;\n    const method = config.method.toUpperCase();\n    let isDone;\n    let rejected = false;\n    let req;\n\n    // temporary internal emitter until the AxiosRequest class will be implemented\n    const emitter = new EventEmitter();\n\n    const onFinished = () => {\n      if (config.cancelToken) {\n        config.cancelToken.unsubscribe(abort);\n      }\n\n      if (config.signal) {\n        config.signal.removeEventListener('abort', abort);\n      }\n\n      emitter.removeAllListeners();\n    }\n\n    onDone((value, isRejected) => {\n      isDone = true;\n      if (isRejected) {\n        rejected = true;\n        onFinished();\n      }\n    });\n\n    function abort(reason) {\n      emitter.emit('abort', !reason || reason.type ? new CanceledError(null, config, req) : reason);\n    }\n\n    emitter.once('abort', reject);\n\n    if (config.cancelToken || config.signal) {\n      config.cancelToken && config.cancelToken.subscribe(abort);\n      if (config.signal) {\n        config.signal.aborted ? abort() : config.signal.addEventListener('abort', abort);\n      }\n    }\n\n    // Parse url\n    const fullPath = buildFullPath(config.baseURL, config.url);\n    const parsed = new URL(fullPath, 'http://localhost');\n    const protocol = parsed.protocol || supportedProtocols[0];\n\n    if (protocol === 'data:') {\n      let convertedData;\n\n      if (method !== 'GET') {\n        return settle(resolve, reject, {\n          status: 405,\n          statusText: 'method not allowed',\n          headers: {},\n          config\n        });\n      }\n\n      try {\n        convertedData = fromDataURI(config.url, responseType === 'blob', {\n          Blob: config.env && config.env.Blob\n        });\n      } catch (err) {\n        throw AxiosError.from(err, AxiosError.ERR_BAD_REQUEST, config);\n      }\n\n      if (responseType === 'text') {\n        convertedData = convertedData.toString(responseEncoding);\n\n        if (!responseEncoding || responseEncoding === 'utf8') {\n          convertedData = utils.stripBOM(convertedData);\n        }\n      } else if (responseType === 'stream') {\n        convertedData = stream.Readable.from(convertedData);\n      }\n\n      return settle(resolve, reject, {\n        data: convertedData,\n        status: 200,\n        statusText: 'OK',\n        headers: new AxiosHeaders(),\n        config\n      });\n    }\n\n    if (supportedProtocols.indexOf(protocol) === -1) {\n      return reject(new AxiosError(\n        'Unsupported protocol ' + protocol,\n        AxiosError.ERR_BAD_REQUEST,\n        config\n      ));\n    }\n\n    const headers = AxiosHeaders.from(config.headers).normalize();\n\n    // Set User-Agent (required by some servers)\n    // See https://github.com/axios/axios/issues/69\n    // User-Agent is specified; handle case where no UA header is desired\n    // Only set header if it hasn't been set in config\n    headers.set('User-Agent', 'axios/' + VERSION, false);\n\n    const onDownloadProgress = config.onDownloadProgress;\n    const onUploadProgress = config.onUploadProgress;\n    const maxRate = config.maxRate;\n    let maxUploadRate = undefined;\n    let maxDownloadRate = undefined;\n\n    // support for spec compliant FormData objects\n    if (utils.isSpecCompliantForm(data)) {\n      const userBoundary = headers.getContentType(/boundary=([-_\\w\\d]{10,70})/i);\n\n      data = formDataToStream(data, (formHeaders) => {\n        headers.set(formHeaders);\n      }, {\n        tag: `axios-${VERSION}-boundary`,\n        boundary: userBoundary && userBoundary[1] || undefined\n      });\n      // support for https://www.npmjs.com/package/form-data api\n    } else if (utils.isFormData(data) && utils.isFunction(data.getHeaders)) {\n      headers.set(data.getHeaders());\n\n      if (!headers.hasContentLength()) {\n        try {\n          const knownLength = await util.promisify(data.getLength).call(data);\n          Number.isFinite(knownLength) && knownLength >= 0 && headers.setContentLength(knownLength);\n          /*eslint no-empty:0*/\n        } catch (e) {\n        }\n      }\n    } else if (utils.isBlob(data)) {\n      data.size && headers.setContentType(data.type || 'application/octet-stream');\n      headers.setContentLength(data.size || 0);\n      data = stream.Readable.from(readBlob(data));\n    } else if (data && !utils.isStream(data)) {\n      if (Buffer.isBuffer(data)) {\n        // Nothing to do...\n      } else if (utils.isArrayBuffer(data)) {\n        data = Buffer.from(new Uint8Array(data));\n      } else if (utils.isString(data)) {\n        data = Buffer.from(data, 'utf-8');\n      } else {\n        return reject(new AxiosError(\n          'Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream',\n          AxiosError.ERR_BAD_REQUEST,\n          config\n        ));\n      }\n\n      // Add Content-Length header if data exists\n      headers.setContentLength(data.length, false);\n\n      if (config.maxBodyLength > -1 && data.length > config.maxBodyLength) {\n        return reject(new AxiosError(\n          'Request body larger than maxBodyLength limit',\n          AxiosError.ERR_BAD_REQUEST,\n          config\n        ));\n      }\n    }\n\n    const contentLength = utils.toFiniteNumber(headers.getContentLength());\n\n    if (utils.isArray(maxRate)) {\n      maxUploadRate = maxRate[0];\n      maxDownloadRate = maxRate[1];\n    } else {\n      maxUploadRate = maxDownloadRate = maxRate;\n    }\n\n    if (data && (onUploadProgress || maxUploadRate)) {\n      if (!utils.isStream(data)) {\n        data = stream.Readable.from(data, {objectMode: false});\n      }\n\n      data = stream.pipeline([data, new AxiosTransformStream({\n        length: contentLength,\n        maxRate: utils.toFiniteNumber(maxUploadRate)\n      })], utils.noop);\n\n      onUploadProgress && data.on('progress', progress => {\n        onUploadProgress(Object.assign(progress, {\n          upload: true\n        }));\n      });\n    }\n\n    // HTTP basic authentication\n    let auth = undefined;\n    if (config.auth) {\n      const username = config.auth.username || '';\n      const password = config.auth.password || '';\n      auth = username + ':' + password;\n    }\n\n    if (!auth && parsed.username) {\n      const urlUsername = parsed.username;\n      const urlPassword = parsed.password;\n      auth = urlUsername + ':' + urlPassword;\n    }\n\n    auth && headers.delete('authorization');\n\n    let path;\n\n    try {\n      path = buildURL(\n        parsed.pathname + parsed.search,\n        config.params,\n        config.paramsSerializer\n      ).replace(/^\\?/, '');\n    } catch (err) {\n      const customErr = new Error(err.message);\n      customErr.config = config;\n      customErr.url = config.url;\n      customErr.exists = true;\n      return reject(customErr);\n    }\n\n    headers.set(\n      'Accept-Encoding',\n      'gzip, compress, deflate' + (isBrotliSupported ? ', br' : ''), false\n      );\n\n    const options = {\n      path,\n      method: method,\n      headers: headers.toJSON(),\n      agents: { http: config.httpAgent, https: config.httpsAgent },\n      auth,\n      protocol,\n      beforeRedirect: dispatchBeforeRedirect,\n      beforeRedirects: {}\n    };\n\n    if (config.socketPath) {\n      options.socketPath = config.socketPath;\n    } else {\n      options.hostname = parsed.hostname;\n      options.port = parsed.port;\n      setProxy(options, config.proxy, protocol + '//' + parsed.hostname + (parsed.port ? ':' + parsed.port : '') + options.path);\n    }\n\n    let transport;\n    const isHttpsRequest = isHttps.test(options.protocol);\n    options.agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;\n    if (config.transport) {\n      transport = config.transport;\n    } else if (config.maxRedirects === 0) {\n      transport = isHttpsRequest ? https : http;\n    } else {\n      if (config.maxRedirects) {\n        options.maxRedirects = config.maxRedirects;\n      }\n      if (config.beforeRedirect) {\n        options.beforeRedirects.config = config.beforeRedirect;\n      }\n      transport = isHttpsRequest ? httpsFollow : httpFollow;\n    }\n\n    if (config.maxBodyLength > -1) {\n      options.maxBodyLength = config.maxBodyLength;\n    } else {\n      // follow-redirects does not skip comparison, so it should always succeed for axios -1 unlimited\n      options.maxBodyLength = Infinity;\n    }\n\n    if (config.insecureHTTPParser) {\n      options.insecureHTTPParser = config.insecureHTTPParser;\n    }\n\n    // Create the request\n    req = transport.request(options, function handleResponse(res) {\n      if (req.destroyed) return;\n\n      const streams = [res];\n\n      const responseLength = +res.headers['content-length'];\n\n      if (onDownloadProgress) {\n        const transformStream = new AxiosTransformStream({\n          length: utils.toFiniteNumber(responseLength),\n          maxRate: utils.toFiniteNumber(maxDownloadRate)\n        });\n\n        onDownloadProgress && transformStream.on('progress', progress => {\n          onDownloadProgress(Object.assign(progress, {\n            download: true\n          }));\n        });\n\n        streams.push(transformStream);\n      }\n\n      // decompress the response body transparently if required\n      let responseStream = res;\n\n      // return the last request in case of redirects\n      const lastRequest = res.req || req;\n\n      // if decompress disabled we should not decompress\n      if (config.decompress !== false && res.headers['content-encoding']) {\n        // if no content, but headers still say that it is encoded,\n        // remove the header not confuse downstream operations\n        if (method === 'HEAD' || res.statusCode === 204) {\n          delete res.headers['content-encoding'];\n        }\n\n        switch (res.headers['content-encoding']) {\n        /*eslint default-case:0*/\n        case 'gzip':\n        case 'x-gzip':\n        case 'compress':\n        case 'x-compress':\n          // add the unzipper to the body stream processing pipeline\n          streams.push(zlib.createUnzip(zlibOptions));\n\n          // remove the content-encoding in order to not confuse downstream operations\n          delete res.headers['content-encoding'];\n          break;\n        case 'deflate':\n          streams.push(new ZlibHeaderTransformStream());\n\n          // add the unzipper to the body stream processing pipeline\n          streams.push(zlib.createUnzip(zlibOptions));\n\n          // remove the content-encoding in order to not confuse downstream operations\n          delete res.headers['content-encoding'];\n          break;\n        case 'br':\n          if (isBrotliSupported) {\n            streams.push(zlib.createBrotliDecompress(brotliOptions));\n            delete res.headers['content-encoding'];\n          }\n        }\n      }\n\n      responseStream = streams.length > 1 ? stream.pipeline(streams, utils.noop) : streams[0];\n\n      const offListeners = stream.finished(responseStream, () => {\n        offListeners();\n        onFinished();\n      });\n\n      const response = {\n        status: res.statusCode,\n        statusText: res.statusMessage,\n        headers: new AxiosHeaders(res.headers),\n        config,\n        request: lastRequest\n      };\n\n      if (responseType === 'stream') {\n        response.data = responseStream;\n        settle(resolve, reject, response);\n      } else {\n        const responseBuffer = [];\n        let totalResponseBytes = 0;\n\n        responseStream.on('data', function handleStreamData(chunk) {\n          responseBuffer.push(chunk);\n          totalResponseBytes += chunk.length;\n\n          // make sure the content length is not over the maxContentLength if specified\n          if (config.maxContentLength > -1 && totalResponseBytes > config.maxContentLength) {\n            // stream.destroy() emit aborted event before calling reject() on Node.js v16\n            rejected = true;\n            responseStream.destroy();\n            reject(new AxiosError('maxContentLength size of ' + config.maxContentLength + ' exceeded',\n              AxiosError.ERR_BAD_RESPONSE, config, lastRequest));\n          }\n        });\n\n        responseStream.on('aborted', function handlerStreamAborted() {\n          if (rejected) {\n            return;\n          }\n\n          const err = new AxiosError(\n            'maxContentLength size of ' + config.maxContentLength + ' exceeded',\n            AxiosError.ERR_BAD_RESPONSE,\n            config,\n            lastRequest\n          );\n          responseStream.destroy(err);\n          reject(err);\n        });\n\n        responseStream.on('error', function handleStreamError(err) {\n          if (req.destroyed) return;\n          reject(AxiosError.from(err, null, config, lastRequest));\n        });\n\n        responseStream.on('end', function handleStreamEnd() {\n          try {\n            let responseData = responseBuffer.length === 1 ? responseBuffer[0] : Buffer.concat(responseBuffer);\n            if (responseType !== 'arraybuffer') {\n              responseData = responseData.toString(responseEncoding);\n              if (!responseEncoding || responseEncoding === 'utf8') {\n                responseData = utils.stripBOM(responseData);\n              }\n            }\n            response.data = responseData;\n          } catch (err) {\n            reject(AxiosError.from(err, null, config, response.request, response));\n          }\n          settle(resolve, reject, response);\n        });\n      }\n\n      emitter.once('abort', err => {\n        if (!responseStream.destroyed) {\n          responseStream.emit('error', err);\n          responseStream.destroy();\n        }\n      });\n    });\n\n    emitter.once('abort', err => {\n      reject(err);\n      req.destroy(err);\n    });\n\n    // Handle errors\n    req.on('error', function handleRequestError(err) {\n      // @todo remove\n      // if (req.aborted && err.code !== AxiosError.ERR_FR_TOO_MANY_REDIRECTS) return;\n      reject(AxiosError.from(err, null, config, req));\n    });\n\n    // set tcp keep alive to prevent drop connection by peer\n    req.on('socket', function handleRequestSocket(socket) {\n      // default interval of sending ack packet is 1 minute\n      socket.setKeepAlive(true, 1000 * 60);\n    });\n\n    // Handle request timeout\n    if (config.timeout) {\n      // This is forcing a int timeout to avoid problems if the `req` interface doesn't handle other types.\n      const timeout = parseInt(config.timeout, 10);\n\n      if (isNaN(timeout)) {\n        reject(new AxiosError(\n          'error trying to parse `config.timeout` to int',\n          AxiosError.ERR_BAD_OPTION_VALUE,\n          config,\n          req\n        ));\n\n        return;\n      }\n\n      // Sometime, the response will be very slow, and does not respond, the connect event will be block by event loop system.\n      // And timer callback will be fired, and abort() will be invoked before connection, then get \"socket hang up\" and code ECONNRESET.\n      // At this time, if we have a large number of request, nodejs will hang up some socket on background. and the number will up and up.\n      // And then these socket which be hang up will devouring CPU little by little.\n      // ClientRequest.setTimeout will be fired on the specify milliseconds, and can make sure that abort() will be fired after connect.\n      req.setTimeout(timeout, function handleRequestTimeout() {\n        if (isDone) return;\n        let timeoutErrorMessage = config.timeout ? 'timeout of ' + config.timeout + 'ms exceeded' : 'timeout exceeded';\n        const transitional = config.transitional || transitionalDefaults;\n        if (config.timeoutErrorMessage) {\n          timeoutErrorMessage = config.timeoutErrorMessage;\n        }\n        reject(new AxiosError(\n          timeoutErrorMessage,\n          transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,\n          config,\n          req\n        ));\n        abort();\n      });\n    }\n\n\n    // Send the request\n    if (utils.isStream(data)) {\n      let ended = false;\n      let errored = false;\n\n      data.on('end', () => {\n        ended = true;\n      });\n\n      data.once('error', err => {\n        errored = true;\n        req.destroy(err);\n      });\n\n      data.on('close', () => {\n        if (!ended && !errored) {\n          abort(new CanceledError('Request stream has been aborted', config, req));\n        }\n      });\n\n      data.pipe(req);\n    } else {\n      req.end(data);\n    }\n  });\n}\n\nexport const __setProxy = setProxy;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}